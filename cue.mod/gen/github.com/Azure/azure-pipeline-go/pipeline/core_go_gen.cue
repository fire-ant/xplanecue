// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/Azure/azure-pipeline-go/pipeline

package pipeline

// The Factory interface represents an object that can create its Policy object. Each HTTP request sent
// requires that this Factory create a new instance of its Policy object.
#Factory: _

// The Policy interface represents a mutable Policy object created by a Factory. The object can mutate/process
// the HTTP request and then forward it on to the next Policy object in the linked-list. The returned
// Response goes backward through the linked-list for additional processing.
// NOTE: Request is passed by value so changes do not change the caller's version of
// the request. However, Request has some fields that reference mutable objects (not strings).
// These references are copied; a deep copy is not performed. Specifically, this means that
// you should avoid modifying the objects referred to by these fields: URL, Header, Body,
// GetBody, TransferEncoding, Form, MultipartForm, Trailer, TLS, Cancel, and Response.
#Policy: _

// Options configures a Pipeline's behavior.
#Options: {
	HTTPSender: #Factory
}

// LogLevel tells a logger the minimum level to log. When code reports a log entry,
// the LogLevel indicates the level of the log entry. The logger only records entries
// whose level is at least the level it was told to log. See the Log* constants.
// For example, if a logger is configured with LogError, then LogError, LogPanic,
// and LogFatal entries will be logged; lower level entries are ignored.
#LogLevel: uint32 // #enumLogLevel

#enumLogLevel:
	#LogNone |
	#LogFatal |
	#LogPanic |
	#LogError |
	#LogWarning |
	#LogInfo |
	#LogDebug

#values_LogLevel: {
	LogNone:    #LogNone
	LogFatal:   #LogFatal
	LogPanic:   #LogPanic
	LogError:   #LogError
	LogWarning: #LogWarning
	LogInfo:    #LogInfo
	LogDebug:   #LogDebug
}

// LogNone tells a logger not to log any entries passed to it.
#LogNone: #LogLevel & 0

// LogFatal tells a logger to log all LogFatal entries passed to it.
#LogFatal: #LogLevel & 1

// LogPanic tells a logger to log all LogPanic and LogFatal entries passed to it.
#LogPanic: #LogLevel & 2

// LogError tells a logger to log all LogError, LogPanic and LogFatal entries passed to it.
#LogError: #LogLevel & 3

// LogWarning tells a logger to log all LogWarning, LogError, LogPanic and LogFatal entries passed to it.
#LogWarning: #LogLevel & 4

// LogInfo tells a logger to log all LogInfo, LogWarning, LogError, LogPanic and LogFatal entries passed to it.
#LogInfo: #LogLevel & 5

// LogDebug tells a logger to log all LogDebug, LogInfo, LogWarning, LogError, LogPanic and LogFatal entries passed to it.
#LogDebug: #LogLevel & 6

// The Pipeline interface represents an ordered list of Factory objects and an object implementing the HTTPSender interface.
// You construct a Pipeline by calling the pipeline.NewPipeline function. To send an HTTP request, call pipeline.NewRequest
// and then call Pipeline's Do method passing a context, the request, and a method-specific Factory (or nil). Passing a
// method-specific Factory allows this one call to Do to inject a Policy into the linked-list. The policy is injected where
// the MethodFactoryMarker (see the pipeline.MethodFactoryMarker function) is in the slice of Factory objects.
//
// When Do is called, the Pipeline object asks each Factory object to construct its Policy object and adds each Policy to a linked-list.
// THen, Do sends the Context and Request through all the Policy objects. The final Policy object sends the request over the network
// (via the HTTPSender object passed to NewPipeline) and the response is returned backwards through all the Policy objects.
// Since Pipeline and Factory objects are goroutine-safe, you typically create 1 Pipeline object and reuse it to make many HTTP requests.
#Pipeline: _

_#methodFactoryMarker: {
}

// LogSanitizer can be implemented to clean secrets from lines logged by ForceLog
// By default no implemetation is provided here, because pipeline may be used in many different
// contexts, so the correct implementation is context-dependent
#LogSanitizer: _
